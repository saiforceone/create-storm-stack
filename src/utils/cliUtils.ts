/**
 * @author SaiForceOne
 * @description A collection of helper functions specific to the CLI
 */
// Core & third-party imports
import * as Constants from 'constants';
import chalk from 'chalk';
import path from 'node:path';
import { access, readFile, writeFile } from 'node:fs/promises';

// STRM Stack imports
import { ConsoleLogger } from './consoleLogger.js';
import { getSTRMCLIRoot } from './fileUtils.js';
import { LocaleManager } from '../cliHelpers/localeManager.js';
import { buildScaffoldOutput, pluralize, titleCase } from './generalUtils.js';
import STRMProjectPkgFile = STRMStackCLI.STRMProjectPkgFile;
import STRMLocaleData = STRMStackCLI.STRMLocaleData;
import ScaffoldOutput = STRMStackCLI.ScaffoldOutput;
import STRMConfigFile = STRMStackCLI.STRMConfigFile;
import STRMModuleArgs = STRMStackCLI.STRMModuleArgs;
import STRMModulesFile = STRMStackCLI.STRMModulesFile;
import STRMModule = STRMStackCLI.STRMModule;
import STRMController = STRMStackCLI.STRMController;
import STRMFERoute = STRMStackCLI.STRMFERoute;

/**
 * @async
 * @description Reads the CLI's package.json file and returns the version or not if it fails
 * @returns {Promise<string|undefined>}
 */
export async function getCLIVersion(): Promise<string | undefined> {
  try {
    const currentUrl = import.meta.url;
    const pkgPath = path.resolve(
      path.normalize(new URL(currentUrl).pathname),
      '../../../',
      'package.json'
    );

    const pkgData = await readFile(pkgPath, {
      encoding: 'utf-8',
    });

    const parsedPkg = JSON.parse(pkgData) as STRMProjectPkgFile;

    return parsedPkg.version;
  } catch (e) {
    ConsoleLogger.printLog(`${e.message}`, 'error');
  }
}

/**
 * @function loadLocaleFile
 * @param {string} locale
 * @description Given a locale, attempts to read the corresponding locale file
 * and load the contents into the LocaleManager (singleton)
 */
export async function loadLocaleFile(locale: string) {
  try {
    const cliRoot = getSTRMCLIRoot();
    const localeFilePath = path.resolve(cliRoot, `locales/${locale}.json`);
    const localeFileData = await readFile(localeFilePath, {
      encoding: 'utf-8',
    });
    const localeData = JSON.parse(localeFileData) as STRMLocaleData;
    LocaleManager.getInstance().setLocaleData(localeData);
    LocaleManager.getInstance().setLocale(locale);
  } catch (e) {
    ConsoleLogger.printLog(`Failed to load locale file error: ${e.toString()}`);
    process.exit(1);
  }
}

/**
 * @async
 * @function checkSTRMProject
 * @param {string} projectDir the directory to be checked
 * @param {boolean} showOutput determines if the output should be shown
 * @description Checks that the target directory contains a STRM Stack Project
 * @returns {Promise<ScaffoldOutput>}
 */
export async function checkSTRMProject(
  projectDir: string,
  showOutput: boolean = false
): Promise<ScaffoldOutput> {
  const output = buildScaffoldOutput();

  try {
    // read the JSON config file
    const configPath = path.resolve(
      projectDir,
      'strm_config',
      'strm_config.json'
    );

    const configData = await readFile(configPath, { encoding: 'utf-8' });
    const parsedConfig = JSON.parse(configData) as STRMConfigFile;

    // check if project has the appropriate files and folders
    const frontendDir = `strm_fe_${parsedConfig.frontend}`;
    const PATHS = [
      frontendDir,
      `${frontendDir}/src/${parsedConfig.frontendEntryPoint}`,
      `${frontendDir}/src/pages`,
      'strm_controllers',
      'strm_models',
      'strm_modules/strm_modules',
      'strm_routes',
      'support/strm_hmr.py',
      'templates/app.html',
      'app.py',
      'vite.config.ts',
      'tailwind.config.ts',
    ];
    // loop over paths and check for read access
    for (const dir of PATHS) {
      await access(path.resolve(projectDir, dir), Constants.R_OK);
      if (showOutput) console.log('✔️ ', dir);
    }

    output.success = true;
    return output;
  } catch (e) {
    output.message = e.message;
    return output;
  }
}

// async function generateModuleRoutes(): Promise<ScaffoldOutput> {}

/**
 * @function writeSTRMModelFile
 * @description given a model name, attempts to create the model file
 * @param {string} modelName the name of the model
 * @returns {Promise<ScaffoldOutput>}
 */
async function writeSTRMModelFile(modelName: string): Promise<ScaffoldOutput> {
  const output = buildScaffoldOutput();
  try {
    const localeData = LocaleManager.getInstance().getLocaleData();
    // build model file
    const modelFileData = `# Generated by the ${
      localeData.misc.STORM_BRANDED
    } ${new Date().toLocaleDateString()}
# Core Imports
import datetime
import mongoengine as me


class ${titleCase(modelName)}(me.Document):
\t"""
\tAutogenerated:
\tRepresents a ${modelName}
\t"""
\tlabel = me.StringField(required=True, max_length=200)
\tupdated_at = me.DateTimeField(default=datetime.datetime.utcnow)\n
    `;
    const modelFilePath = path.resolve(
      process.cwd(),
      `strm_models/${modelName}.py`
    );
    await writeFile(modelFilePath, modelFileData);
    output.success = true;
    return output;
  } catch (e) {
    output.message = e.message;
    return output;
  }
}

/**
 * @async
 * @function getSTRMModules
 * @description Helper function that attempts to read the strm_modules.json file and returns a typed object or not
 * @returns {Promise<STRMModulesFile|undefined>}
 */
async function getSTRMModules(): Promise<STRMModulesFile | undefined> {
  try {
    const modulesFilePath = path.resolve(
      process.cwd(),
      'strm_modules/strm_modules.json'
    );
    const modulesFileStringData = await readFile(modulesFilePath, {
      encoding: 'utf-8',
    });
    return JSON.parse(modulesFileStringData) as STRMModulesFile;
  } catch (e) {
    return;
  }
}

/**
 * @function writeSTRMModulesFile
 * @description Given STRMModulesFile data, attempts to write to the filesystem
 * @param {STRMModulesFile} strmModulesFile the STRMModules files data that should be written to the filesystem
 * @returns {Promise<ScaffoldOutput>}
 */
async function writeSTRMModulesFile(
  strmModulesFile: STRMModulesFile
): Promise<ScaffoldOutput> {
  const output = buildScaffoldOutput();
  try {
    const targetPath = path.resolve(
      process.cwd(),
      'strm_modules/strm_modules.json'
    );
    strmModulesFile.lastUpdated = new Date().toISOString();
    const dataToWrite = JSON.stringify(strmModulesFile, undefined, 2);
    await writeFile(targetPath, dataToWrite);

    output.success = true;
    return output;
  } catch (e) {
    output.message = e.message;
    return output;
  }
}

/**
 * @function buildSTRMModule
 * @description Helper function that constructs a STRM module based on the given parameters
 * @param {STRMModuleArgs} moduleArgs command line arguments passed in
 * @returns {STRMModule} an object representing a module
 */
function buildSTRMModule(moduleArgs: STRMModuleArgs): STRMModule {
  const { name, controllerOnly } = moduleArgs;

  const pluralizedName = pluralize(name);
  const lowercaseName = name.toLowerCase();
  // setup controller
  const controller: STRMController = {
    controllerName: `${lowercaseName}_controller`,
    modelName: `${lowercaseName}.py`,
    endpointBase: pluralizedName,
  };

  const pages: Array<STRMFERoute> = [];

  // setup pages (if controllerOnly = false)
  if (!controllerOnly) {
    const indexPage: STRMFERoute = {
      path: `/${pluralizedName}`,
      componentName: titleCase(name),
      componentPath: `${titleCase(pluralizedName)}/Index`,
    };

    const detailsPage: STRMFERoute = {
      path: `/${pluralizedName}/:id`,
      componentName: `${titleCase(name)}Detail`,
      componentPath: `${titleCase(pluralizedName)}/${titleCase(name)}`,
    };

    pages.push(indexPage, detailsPage);
  }

  return {
    controller,
    controllerOnly: !!controllerOnly,
    pages,
  };
}

/**
 * @async
 * @function createSTRMModule
 * @description Utility function that handles the creation of a STRM Stack Module
 * @param {STRMModuleArgs} moduleArgs
 * @returns {Promise<ScaffoldOutput>} Standard scaffold output indicating the result of attempting to create a module
 */
export async function createSTRMModule(
  moduleArgs: STRMModuleArgs
): Promise<ScaffoldOutput> {
  const output = buildScaffoldOutput();
  try {
    const { name } = moduleArgs;
    console.log(chalk.blueBright.bold('Attempting to update STRM Modules...'));
    // 0. read configuration
    const strmModulesFileData = await getSTRMModules();
    if (!strmModulesFileData) {
      output.message = 'Failed to read STRMModules file';
      return output;
    }
    // 0.1 update modules JSON file
    strmModulesFileData.modules[name] = buildSTRMModule(moduleArgs);
    const writeModulesResult = await writeSTRMModulesFile(strmModulesFileData);
    if (!writeModulesResult.success) {
      output.message = 'Failed to write Modules';
      console.log(chalk.redBright.bold('Failed to update STRM Modules file'));
      return output;
    }
    console.log(chalk.greenBright.bold('Updated STRM Modules.'));
    // 1. build model
    console.log(
      chalk.dim.bold(
        `Attempting to create module file ${chalk.blueBright.bold(
          `strm_models/${name.toLowerCase()}.py`
        )}`
      )
    );
    const modelResult = await writeSTRMModelFile(name);
    if (!modelResult.success) {
      output.message = modelResult.message;
      console.log(chalk.redBright.bold('Failed to create model file'));
      return output;
    }
    console.log(
      chalk.greenBright.bold(
        `Successfully created model file ${chalk.italic(
          `strm_models/${name.toLowerCase()}.py`
        )}`
      )
    );
    // 2. build controller
    // 3. rewrite backend routes
    // 4. build frontend components

    output.success = true;
    return output;
  } catch (e) {
    output.message = e.message;
    return output;
  }
}
